<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CCIP Router Diagnostic Test</title>
    <style>
      body {
        font-family: "Courier New", monospace;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #1a1a1a;
        color: #e0e0e0;
      }

      .section {
        background: #2d2d2d;
        border: 1px solid #555;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
      }

      .section h2 {
        color: #4caf50;
        margin-top: 0;
      }

      button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        margin: 5px;
        font-size: 14px;
      }

      button:hover {
        background: #45a049;
      }

      .error {
        background: #ff4444;
      }

      .error:hover {
        background: #cc3333;
      }

      pre {
        background: #1e1e1e;
        padding: 15px;
        border-radius: 4px;
        border-left: 4px solid #4caf50;
        overflow-x: auto;
        max-height: 400px;
        overflow-y: auto;
      }

      .log {
        background: #1e1e1e;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        max-height: 300px;
        overflow-y: auto;
        font-size: 12px;
      }

      .success {
        color: #4caf50;
      }
      .warning {
        color: #ff9800;
      }
      .error-text {
        color: #ff4444;
      }
      .info {
        color: #2196f3;
      }
    </style>
  </head>
  <body>
    <h1>üîç CCIP Router Diagnostic Test</h1>
    <p>Comprehensive CCIP Router and network validation</p>

    <div class="section">
      <h2>üìä Network Status</h2>
      <div id="networkStatus">
        <div>Network: <span id="currentNetwork">Unknown</span></div>
        <div>Account: <span id="currentAccount">Not connected</span></div>
        <div>Chain ID: <span id="currentChainId">Unknown</span></div>
      </div>
    </div>

    <div class="section">
      <h2>üîß CCIP Router Tests</h2>
      <button onclick="testRouterConnection()">
        üîó Test Router Connection
      </button>
      <button onclick="testChainSupport()">üåê Test Chain Support</button>
      <button onclick="testTokenSupport()">üí∞ Test Token Support</button>
      <button onclick="testAllowanceAndBalance()">
        üí≥ Test Allowance & Balance
      </button>
      <button onclick="runFullDiagnostic()">üöÄ Run Full Diagnostic</button>
      <button onclick="clearLogs()" class="error">üóëÔ∏è Clear Logs</button>
    </div>

    <div class="section">
      <h2>üìã Diagnostic Log</h2>
      <div class="log" id="diagnosticLog">
        <div class="info">Ready to run diagnostics...</div>
      </div>
    </div>

    <div class="section">
      <h2>üîç Detailed Results</h2>
      <div id="detailedResults">
        <pre>No diagnostic results yet</pre>
      </div>
    </div>

    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
    <script>
      // Configuration
      const CONFIG = {
        BASE_SEPOLIA: {
          chainId: 84532,
          name: "Base Sepolia",
          router: "0xD3b06cEbF099CE7DA4AcCf578aaebFDBd6e88a93",
          usdc: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
          chainSelector: "10344971235874465080",
        },
        ETHEREUM_SEPOLIA: {
          chainId: 11155111,
          name: "Ethereum Sepolia",
          router: "0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59",
          usdc: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
          chainSelector: "16015286601757825753",
        },
      };

      // Basic CCIP Router ABI for testing
      const ROUTER_ABI = [
        "function isChainSupported(uint64 chainSelector) external view returns (bool)",
        "function getSupportedTokens(uint64 chainSelector) external view returns (address[])",
        "function getFee(uint64 destinationChainSelector, tuple(bytes receiver, bytes data, tuple(address token, uint256 amount)[] tokenAmounts, address feeToken, bytes extraArgs) message) external view returns (uint256)",
        "function ccipSend(uint64 destinationChainSelector, tuple(bytes receiver, bytes data, tuple(address token, uint256 amount)[] tokenAmounts, address feeToken, bytes extraArgs) message) external payable returns (bytes32)",
      ];

      const ERC20_ABI = [
        "function balanceOf(address owner) view returns (uint256)",
        "function allowance(address owner, address spender) view returns (uint256)",
      ];

      function log(message, type = "info") {
        const logElement = document.getElementById("diagnosticLog");
        const timestamp = new Date().toLocaleTimeString();
        const className = type;
        logElement.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
        logElement.scrollTop = logElement.scrollHeight;
      }

      function displayResults(results) {
        document.getElementById(
          "detailedResults"
        ).innerHTML = `<pre>${JSON.stringify(results, null, 2)}</pre>`;
      }

      async function updateNetworkStatus() {
        try {
          if (window.ethereum) {
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const network = await provider.getNetwork();
            const accounts = await window.ethereum.request({
              method: "eth_accounts",
            });

            document.getElementById("currentNetwork").textContent =
              network.name || "Unknown";
            document.getElementById("currentChainId").textContent =
              network.chainId;
            document.getElementById("currentAccount").textContent = accounts[0]
              ? `${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`
              : "Not connected";
          } else {
            document.getElementById("currentNetwork").textContent =
              "MetaMask not available";
          }
        } catch (error) {
          log(`Network status error: ${error.message}`, "error-text");
        }
      }

      window.testRouterConnection = async function () {
        try {
          log("üîó Testing CCIP Router connection...", "info");

          if (!window.ethereum) {
            log("‚ùå MetaMask not available", "error-text");
            return;
          }

          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const network = await provider.getNetwork();
          const chainId = network.chainId;

          let config;
          if (chainId === CONFIG.BASE_SEPOLIA.chainId) {
            config = CONFIG.BASE_SEPOLIA;
          } else if (chainId === CONFIG.ETHEREUM_SEPOLIA.chainId) {
            config = CONFIG.ETHEREUM_SEPOLIA;
          } else {
            log(`‚ùå Unsupported network: ${chainId}`, "error-text");
            return;
          }

          log(`‚úÖ Connected to ${config.name}`, "success");
          log(`üîó Router address: ${config.router}`, "info");

          const routerContract = new ethers.Contract(
            config.router,
            ROUTER_ABI,
            provider
          );

          // Test if we can call a basic function
          try {
            const code = await provider.getCode(config.router);
            if (code === "0x") {
              log("‚ùå Router contract not found at address", "error-text");
              return;
            }
            log(`‚úÖ Router contract found (${code.length} bytes)`, "success");
          } catch (error) {
            log(`‚ùå Router connection failed: ${error.message}`, "error-text");
          }
        } catch (error) {
          log(
            `üö® Router connection test failed: ${error.message}`,
            "error-text"
          );
        }
      };

      window.testChainSupport = async function () {
        try {
          log("üåê Testing chain support...", "info");

          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const network = await provider.getNetwork();
          const chainId = network.chainId;

          const config =
            chainId === CONFIG.BASE_SEPOLIA.chainId
              ? CONFIG.BASE_SEPOLIA
              : CONFIG.ETHEREUM_SEPOLIA;
          const routerContract = new ethers.Contract(
            config.router,
            ROUTER_ABI,
            provider
          );

          // Test destination chain support
          const destinationConfig =
            chainId === CONFIG.BASE_SEPOLIA.chainId
              ? CONFIG.ETHEREUM_SEPOLIA
              : CONFIG.BASE_SEPOLIA;

          log(
            `üìã Testing support for destination: ${destinationConfig.name}`,
            "info"
          );
          log(
            `üìã Destination selector: ${destinationConfig.chainSelector}`,
            "info"
          );

          const isSupported = await routerContract.isChainSupported(
            destinationConfig.chainSelector
          );
          log(
            `üéØ Chain supported: ${isSupported}`,
            isSupported ? "success" : "error-text"
          );

          if (!isSupported) {
            log("‚ùå This explains why CCIP transactions fail!", "error-text");
          }

          displayResults({
            sourceChain: config.name,
            destinationChain: destinationConfig.name,
            destinationSelector: destinationConfig.chainSelector,
            isSupported: isSupported,
          });
        } catch (error) {
          log(`üö® Chain support test failed: ${error.message}`, "error-text");
        }
      };

      window.testTokenSupport = async function () {
        try {
          log("üí∞ Testing token support...", "info");

          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const network = await provider.getNetwork();
          const chainId = network.chainId;

          const config =
            chainId === CONFIG.BASE_SEPOLIA.chainId
              ? CONFIG.BASE_SEPOLIA
              : CONFIG.ETHEREUM_SEPOLIA;
          const routerContract = new ethers.Contract(
            config.router,
            ROUTER_ABI,
            provider
          );

          const destinationConfig =
            chainId === CONFIG.BASE_SEPOLIA.chainId
              ? CONFIG.ETHEREUM_SEPOLIA
              : CONFIG.BASE_SEPOLIA;

          try {
            const supportedTokens = await routerContract.getSupportedTokens(
              destinationConfig.chainSelector
            );
            log(`üìã Supported tokens on ${destinationConfig.name}:`, "info");
            supportedTokens.forEach((token, index) => {
              log(`  ${index + 1}. ${token}`, "info");
              if (token.toLowerCase() === config.usdc.toLowerCase()) {
                log(`    ‚úÖ This is our USDC token!`, "success");
              }
            });

            const isUSDCSupported = supportedTokens.some(
              (token) => token.toLowerCase() === config.usdc.toLowerCase()
            );

            log(
              `üéØ USDC supported: ${isUSDCSupported}`,
              isUSDCSupported ? "success" : "error-text"
            );

            displayResults({
              supportedTokens: supportedTokens,
              usdcAddress: config.usdc,
              isUSDCSupported: isUSDCSupported,
            });
          } catch (error) {
            log(
              `‚ùå Could not get supported tokens: ${error.message}`,
              "error-text"
            );
          }
        } catch (error) {
          log(`üö® Token support test failed: ${error.message}`, "error-text");
        }
      };

      window.testAllowanceAndBalance = async function () {
        try {
          log("üí≥ Testing allowance and balance...", "info");

          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts",
          });
          const userAddress = accounts[0];

          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const network = await provider.getNetwork();
          const chainId = network.chainId;

          const config =
            chainId === CONFIG.BASE_SEPOLIA.chainId
              ? CONFIG.BASE_SEPOLIA
              : CONFIG.ETHEREUM_SEPOLIA;

          const usdcContract = new ethers.Contract(
            config.usdc,
            ERC20_ABI,
            provider
          );

          // Check USDC balance
          const balance = await usdcContract.balanceOf(userAddress);
          const balanceUSDC = ethers.utils.formatUnits(balance, 6);
          log(`üí∞ USDC Balance: ${balanceUSDC} USDC`, "info");

          // Check allowance to router
          const allowance = await usdcContract.allowance(
            userAddress,
            config.router
          );
          const allowanceUSDC = ethers.utils.formatUnits(allowance, 6);
          log(`üîì USDC Allowance to Router: ${allowanceUSDC} USDC`, "info");

          // Check ETH balance
          const ethBalance = await provider.getBalance(userAddress);
          const ethBalanceFormatted = ethers.utils.formatEther(ethBalance);
          log(`‚ö° ETH Balance: ${ethBalanceFormatted} ETH`, "info");

          const hasUSDC = parseFloat(balanceUSDC) >= 4;
          const hasAllowance = parseFloat(allowanceUSDC) >= 4;
          const hasETH = parseFloat(ethBalanceFormatted) >= 0.001;

          log(`üéØ Has 4+ USDC: ${hasUSDC}`, hasUSDC ? "success" : "error-text");
          log(
            `üéØ Has 4+ USDC allowance: ${hasAllowance}`,
            hasAllowance ? "success" : "error-text"
          );
          log(
            `üéØ Has ETH for fees: ${hasETH}`,
            hasETH ? "success" : "error-text"
          );

          displayResults({
            userAddress: userAddress,
            usdcBalance: balanceUSDC,
            usdcAllowance: allowanceUSDC,
            ethBalance: ethBalanceFormatted,
            hasUSDC: hasUSDC,
            hasAllowance: hasAllowance,
            hasETH: hasETH,
          });
        } catch (error) {
          log(
            `üö® Balance/allowance test failed: ${error.message}`,
            "error-text"
          );
        }
      };

      window.runFullDiagnostic = async function () {
        log("üöÄ Running full CCIP diagnostic...", "success");
        await testRouterConnection();
        await new Promise((resolve) => setTimeout(resolve, 1000));
        await testChainSupport();
        await new Promise((resolve) => setTimeout(resolve, 1000));
        await testTokenSupport();
        await new Promise((resolve) => setTimeout(resolve, 1000));
        await testAllowanceAndBalance();
        log("‚úÖ Full diagnostic completed!", "success");
      };

      window.clearLogs = function () {
        document.getElementById("diagnosticLog").innerHTML =
          '<div class="info">Logs cleared - Ready for new tests...</div>';
      };

      // Initialize
      updateNetworkStatus();

      // Update network status when account or network changes
      if (window.ethereum) {
        window.ethereum.on("accountsChanged", updateNetworkStatus);
        window.ethereum.on("chainChanged", updateNetworkStatus);
      }

      log("üöÄ CCIP Diagnostic Tool Ready", "success");
      log('Click "Run Full Diagnostic" to test all CCIP components', "info");
    </script>
  </body>
</html>
